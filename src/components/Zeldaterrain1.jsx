/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/zeldaterrain1.glb --transform 
Files: public/models/zeldaterrain1.glb [17.65MB] > C:\Users\tibog\Documents\VSCODE\wawa-game\zeldaterrain1-transformed.glb [1.56MB] (91%)
*/

import React, { useEffect, useMemo } from "react";
import { useGLTF } from "@react-three/drei";
import * as THREE from "three";

export function Zeldaterrain1({ onHeightmapReady, ...props }) {
  const { nodes, materials } = useGLTF("/models/zeldaterrain1-transformed.glb");

  // Build height grid from mesh geometry - FAST vertex bucketing approach
  const heightmapLookup = useMemo(() => {
    if (!nodes.Plane?.geometry) return null;

    const geometry = nodes.Plane.geometry;
    const position = geometry.attributes.position;

    if (!position) return null;

    console.log("üó∫Ô∏è Building height grid for Zeldaterrain1 (FAST method)...");

    // Get bounding box to determine terrain bounds
    if (!geometry.boundingBox) {
      geometry.computeBoundingBox();
    }
    const bbox = geometry.boundingBox;
    const minX = bbox.min.x;
    const maxX = bbox.max.x;
    const minY = bbox.min.y;
    const maxY = bbox.max.y;
    const minZ = bbox.min.z;
    const maxZ = bbox.max.z;
    const width = maxX - minX;
    const height = maxZ - minZ;

    console.log(
      `üìè Terrain bounds: X[${minX.toFixed(2)}, ${maxX.toFixed(
        2
      )}], Z[${minZ.toFixed(2)}, ${maxZ.toFixed(2)}], Y[${minY.toFixed(
        2
      )}, ${maxY.toFixed(2)}]`
    );
    console.log(`üî¢ Vertex count: ${position.count}`);

    // Create height grid (64x64 for good balance)
    const gridResolution = 512;
    const heightGrid = [];
    const countGrid = []; // Track how many vertices contributed to each cell

    // Initialize grids
    for (let gz = 0; gz < gridResolution; gz++) {
      heightGrid[gz] = [];
      countGrid[gz] = [];
      for (let gx = 0; gx < gridResolution; gx++) {
        heightGrid[gz][gx] = 0;
        countGrid[gz][gx] = 0;
      }
    }

    console.log(`‚è≥ Processing ${position.count} vertices...`);

    // FAST: Iterate through vertices ONCE and bucket them into grid cells
    for (let i = 0; i < position.count; i++) {
      const vx = position.getX(i);
      const vz = position.getZ(i);
      const vy = position.getY(i);

      // Convert vertex position to grid coordinates
      const normalizedX = (vx - minX) / width;
      const normalizedZ = (vz - minZ) / height;

      // Skip if outside bounds
      if (
        normalizedX < 0 ||
        normalizedX > 1 ||
        normalizedZ < 0 ||
        normalizedZ > 1
      ) {
        continue;
      }

      const gridX = Math.floor(normalizedX * (gridResolution - 1));
      const gridZ = Math.floor(normalizedZ * (gridResolution - 1));

      // Clamp to valid indices
      const gx = Math.max(0, Math.min(gridResolution - 1, gridX));
      const gz = Math.max(0, Math.min(gridResolution - 1, gridZ));

      // Accumulate height (we'll average later)
      heightGrid[gz][gx] += vy;
      countGrid[gz][gx] += 1;
    }

    // Average the accumulated heights
    for (let gz = 0; gz < gridResolution; gz++) {
      for (let gx = 0; gx < gridResolution; gx++) {
        if (countGrid[gz][gx] > 0) {
          heightGrid[gz][gx] = heightGrid[gz][gx] / countGrid[gz][gx];
        } else {
          // If no vertices in this cell, use minY as fallback
          heightGrid[gz][gx] = minY;
        }
      }
    }

    // Fill any remaining holes by interpolating from neighbors
    for (let gz = 0; gz < gridResolution; gz++) {
      for (let gx = 0; gx < gridResolution; gx++) {
        if (countGrid[gz][gx] === 0) {
          // Find nearest non-empty cell
          let sum = 0;
          let count = 0;

          for (let dz = -1; dz <= 1; dz++) {
            for (let dx = -1; dx <= 1; dx++) {
              const ngx = gx + dx;
              const ngz = gz + dz;
              if (
                ngx >= 0 &&
                ngx < gridResolution &&
                ngz >= 0 &&
                ngz < gridResolution
              ) {
                if (countGrid[ngz][ngx] > 0) {
                  sum += heightGrid[ngz][ngx];
                  count++;
                }
              }
            }
          }

          if (count > 0) {
            heightGrid[gz][gx] = sum / count;
          }
        }
      }
    }

    console.log("‚úÖ Height grid built successfully in O(n) time!");

    // Return lookup function with bilinear interpolation
    return (x, z) => {
      // Convert world coords to grid coords
      const normalizedX = (x - minX) / width;
      const normalizedZ = (z - minZ) / height;

      // Clamp to valid range
      const clampedX = Math.max(0, Math.min(1, normalizedX));
      const clampedZ = Math.max(0, Math.min(1, normalizedZ));

      // Get grid position
      const gridX = clampedX * (gridResolution - 1);
      const gridZ = clampedZ * (gridResolution - 1);

      // Get integer and fractional parts for interpolation
      const x0 = Math.floor(gridX);
      const x1 = Math.min(x0 + 1, gridResolution - 1);
      const z0 = Math.floor(gridZ);
      const z1 = Math.min(z0 + 1, gridResolution - 1);
      const fx = gridX - x0;
      const fz = gridZ - z0;

      // Bilinear interpolation
      const h00 = heightGrid[z0][x0];
      const h10 = heightGrid[z0][x1];
      const h01 = heightGrid[z1][x0];
      const h11 = heightGrid[z1][x1];

      const h0 = h00 * (1 - fx) + h10 * fx;
      const h1 = h01 * (1 - fx) + h11 * fx;
      const finalHeight = h0 * (1 - fz) + h1 * fz;

      return finalHeight;
    };
  }, [nodes]);

  // Notify parent when heightmap is ready
  useEffect(() => {
    if (heightmapLookup && onHeightmapReady) {
      console.log("üì§ Passing heightmap lookup to parent");
      onHeightmapReady(heightmapLookup);
    }
  }, [heightmapLookup, onHeightmapReady]);

  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.Plane.geometry}
        material={nodes.Plane.material}
        receiveShadow
        castShadow
      />
    </group>
  );
}

useGLTF.preload("/models/zeldaterrain1-transformed.glb");
